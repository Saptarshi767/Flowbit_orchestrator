"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vulnerabilityScanner = exports.VulnerabilityScanner = void 0;
const child_process_1 = require("child_process");
const util_1 = require("util");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const execAsync = (0, util_1.promisify)(child_process_1.exec);
class VulnerabilityScanner {
    constructor() {
        this.scanResults = new Map();
        this.scanQueue = [];
        this.isScanning = false;
        this.scanHistory = [];
    }
    async scanDependencies(projectPath) {
        const reportId = `dep-${Date.now()}`;
        const startTime = Date.now();
        try {
            // Use npm audit for Node.js dependencies
            const { stdout, stderr } = await execAsync('npm audit --json', {
                cwd: projectPath,
                timeout: 300000 // 5 minutes timeout
            });
            const auditResult = JSON.parse(stdout);
            const vulnerabilities = this.parseNpmAuditResult(auditResult);
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'dependency',
                status: 'completed',
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                metadata: {
                    scanner: 'npm-audit',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            return report;
        }
        catch (error) {
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'dependency',
                status: 'failed',
                vulnerabilities: [],
                summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
                metadata: {
                    scanner: 'npm-audit',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            throw new Error(`Dependency scan failed: ${error}`);
        }
    }
    async scanContainer(imageName) {
        const reportId = `container-${Date.now()}`;
        const startTime = Date.now();
        try {
            // Use Trivy for container scanning
            const { stdout } = await execAsync(`trivy image --format json ${imageName}`, {
                timeout: 600000 // 10 minutes timeout
            });
            const trivyResult = JSON.parse(stdout);
            const vulnerabilities = this.parseTrivyResult(trivyResult);
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'container',
                status: 'completed',
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                metadata: {
                    scanner: 'trivy',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            return report;
        }
        catch (error) {
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'container',
                status: 'failed',
                vulnerabilities: [],
                summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
                metadata: {
                    scanner: 'trivy',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            throw new Error(`Container scan failed: ${error}`);
        }
    }
    async scanCode(projectPath) {
        const reportId = `code-${Date.now()}`;
        const startTime = Date.now();
        try {
            // Use Semgrep for static code analysis
            const { stdout } = await execAsync(`semgrep --config=auto --json ${projectPath}`, {
                timeout: 600000 // 10 minutes timeout
            });
            const semgrepResult = JSON.parse(stdout);
            const vulnerabilities = this.parseSemgrepResult(semgrepResult);
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'code',
                status: 'completed',
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                metadata: {
                    scanner: 'semgrep',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            return report;
        }
        catch (error) {
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'code',
                status: 'failed',
                vulnerabilities: [],
                summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
                metadata: {
                    scanner: 'semgrep',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            throw new Error(`Code scan failed: ${error}`);
        }
    }
    async getReport(reportId) {
        return this.scanResults.get(reportId);
    }
    async getAllReports() {
        return Array.from(this.scanResults.values());
    }
    async generateComplianceReport() {
        const reports = await this.getAllReports();
        const criticalVulns = reports.flatMap(r => r.vulnerabilities.filter(v => v.severity === 'critical'));
        return {
            timestamp: new Date(),
            totalScans: reports.length,
            criticalVulnerabilities: criticalVulns.length,
            complianceStatus: criticalVulns.length === 0 ? 'compliant' : 'non-compliant',
            recommendations: this.generateRecommendations(reports)
        };
    }
    parseNpmAuditResult(auditResult) {
        const vulnerabilities = [];
        if (auditResult.vulnerabilities) {
            for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities)) {
                const vuln = vulnData;
                vulnerabilities.push({
                    id: `npm-${packageName}-${vuln.via[0]?.source || 'unknown'}`,
                    title: vuln.title || `Vulnerability in ${packageName}`,
                    description: vuln.via[0]?.title || 'No description available',
                    severity: this.mapSeverity(vuln.severity),
                    cvss: vuln.via[0]?.cvss?.score || 0,
                    cve: vuln.via[0]?.cve,
                    package: packageName,
                    version: vuln.via[0]?.range || 'unknown',
                    fixedVersion: vuln.fixAvailable?.version,
                    references: vuln.via[0]?.url ? [vuln.via[0].url] : [],
                    remediation: vuln.fixAvailable ? `Update to version ${vuln.fixAvailable.version}` : 'No fix available'
                });
            }
        }
        return vulnerabilities;
    }
    parseTrivyResult(trivyResult) {
        const vulnerabilities = [];
        if (trivyResult.Results) {
            for (const result of trivyResult.Results) {
                if (result.Vulnerabilities) {
                    for (const vuln of result.Vulnerabilities) {
                        vulnerabilities.push({
                            id: vuln.VulnerabilityID,
                            title: vuln.Title || vuln.VulnerabilityID,
                            description: vuln.Description || 'No description available',
                            severity: this.mapSeverity(vuln.Severity),
                            cvss: vuln.CVSS?.nvd?.V3Score || 0,
                            cve: vuln.VulnerabilityID,
                            package: vuln.PkgName,
                            version: vuln.InstalledVersion,
                            fixedVersion: vuln.FixedVersion,
                            references: vuln.References || [],
                            remediation: vuln.FixedVersion ? `Update to version ${vuln.FixedVersion}` : 'No fix available'
                        });
                    }
                }
            }
        }
        return vulnerabilities;
    }
    parseSemgrepResult(semgrepResult) {
        const vulnerabilities = [];
        if (semgrepResult.results) {
            for (const result of semgrepResult.results) {
                vulnerabilities.push({
                    id: `semgrep-${result.check_id}`,
                    title: result.extra?.message || result.check_id,
                    description: result.extra?.message || 'Code security issue detected',
                    severity: this.mapSemgrepSeverity(result.extra?.severity),
                    cvss: this.severityToCvss(result.extra?.severity),
                    references: result.extra?.references || [],
                    remediation: result.extra?.fix || 'Review and fix the identified code issue'
                });
            }
        }
        return vulnerabilities;
    }
    mapSeverity(severity) {
        const severityMap = {
            'critical': 'critical',
            'high': 'high',
            'moderate': 'medium',
            'medium': 'medium',
            'low': 'low',
            'info': 'low'
        };
        return severityMap[severity.toLowerCase()] || 'medium';
    }
    mapSemgrepSeverity(severity) {
        const severityMap = {
            'error': 'high',
            'warning': 'medium',
            'info': 'low'
        };
        return severityMap[severity?.toLowerCase()] || 'medium';
    }
    severityToCvss(severity) {
        const cvssMap = {
            'critical': 9.0,
            'high': 7.0,
            'medium': 5.0,
            'low': 3.0
        };
        return cvssMap[severity?.toLowerCase()] || 5.0;
    }
    calculateSummary(vulnerabilities) {
        const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };
        for (const vuln of vulnerabilities) {
            summary.total++;
            summary[vuln.severity]++;
        }
        return summary;
    }
    generateRecommendations(reports) {
        const recommendations = [];
        const criticalCount = reports.reduce((sum, r) => sum + r.summary.critical, 0);
        const highCount = reports.reduce((sum, r) => sum + r.summary.high, 0);
        if (criticalCount > 0) {
            recommendations.push(`Address ${criticalCount} critical vulnerabilities immediately`);
        }
        if (highCount > 0) {
            recommendations.push(`Plan remediation for ${highCount} high-severity vulnerabilities`);
        }
        recommendations.push('Implement automated vulnerability scanning in CI/CD pipeline');
        recommendations.push('Establish regular security review processes');
        return recommendations;
    }
    // Enhanced scanning capabilities
    async scheduleScan(scanType, target, schedule) {
        const jobId = `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const job = {
            id: jobId,
            scanType,
            target,
            schedule,
            status: 'queued',
            createdAt: new Date()
        };
        this.scanQueue.push(job);
        this.processScanQueue();
        return jobId;
    }
    async processScanQueue() {
        if (this.isScanning || this.scanQueue.length === 0)
            return;
        this.isScanning = true;
        while (this.scanQueue.length > 0) {
            const job = this.scanQueue.shift();
            job.status = 'running';
            job.startedAt = new Date();
            try {
                let report;
                switch (job.scanType) {
                    case 'dependency':
                        report = await this.scanDependencies(job.target);
                        break;
                    case 'container':
                        report = await this.scanContainer(job.target);
                        break;
                    case 'code':
                        report = await this.scanCode(job.target);
                        break;
                    case 'infrastructure':
                        report = await this.scanInfrastructure(job.target);
                        break;
                    default:
                        throw new Error(`Unknown scan type: ${job.scanType}`);
                }
                job.status = 'completed';
                job.completedAt = new Date();
                job.reportId = report.id;
                this.scanHistory.push({
                    jobId: job.id,
                    scanType: job.scanType,
                    target: job.target,
                    status: 'completed',
                    vulnerabilityCount: report.summary.total,
                    criticalCount: report.summary.critical,
                    timestamp: new Date()
                });
            }
            catch (error) {
                job.status = 'failed';
                job.error = error instanceof Error ? error.message : String(error);
                job.completedAt = new Date();
                this.scanHistory.push({
                    jobId: job.id,
                    scanType: job.scanType,
                    target: job.target,
                    status: 'failed',
                    error: job.error,
                    timestamp: new Date()
                });
            }
        }
        this.isScanning = false;
    }
    async scanInfrastructure(target) {
        const reportId = `infra-${Date.now()}`;
        const startTime = Date.now();
        try {
            // Simulate infrastructure scanning (replace with actual tools like Nessus, OpenVAS)
            const vulnerabilities = await this.performInfrastructureScan(target);
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'infrastructure',
                status: 'completed',
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                metadata: {
                    scanner: 'infrastructure-scanner',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            return report;
        }
        catch (error) {
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'infrastructure',
                status: 'failed',
                vulnerabilities: [],
                summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
                metadata: {
                    scanner: 'infrastructure-scanner',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            throw new Error(`Infrastructure scan failed: ${error}`);
        }
    }
    async performInfrastructureScan(target) {
        // Mock infrastructure vulnerabilities - replace with actual scanning logic
        const mockVulnerabilities = [
            {
                id: 'infra-001',
                title: 'Outdated SSL/TLS Configuration',
                description: 'Server supports deprecated TLS versions',
                severity: 'medium',
                cvss: 5.3,
                references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228'],
                remediation: 'Update SSL/TLS configuration to support only TLS 1.2 and above'
            },
            {
                id: 'infra-002',
                title: 'Open Administrative Ports',
                description: 'Administrative ports are accessible from the internet',
                severity: 'high',
                cvss: 7.5,
                references: ['https://owasp.org/www-project-top-ten/'],
                remediation: 'Restrict access to administrative ports using firewall rules'
            }
        ];
        return mockVulnerabilities;
    }
    async generateSBOM(projectPath) {
        // Software Bill of Materials generation
        const packageJsonPath = path_1.default.join(projectPath, 'package.json');
        try {
            const packageJson = JSON.parse(await promises_1.default.readFile(packageJsonPath, 'utf-8'));
            const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
            const components = Object.entries(dependencies).map(([name, version]) => ({
                name,
                version: String(version).replace(/^[\^~]/, ''),
                type: 'library',
                supplier: 'npm',
                licenses: [], // Would need to fetch from package info
                hashes: [] // Would need to calculate from package files
            }));
            return {
                bomFormat: 'CycloneDX',
                specVersion: '1.4',
                version: 1,
                metadata: {
                    timestamp: new Date(),
                    tools: ['vulnerability-scanner'],
                    component: {
                        name: packageJson.name || 'unknown',
                        version: packageJson.version || '1.0.0',
                        type: 'application'
                    }
                },
                components
            };
        }
        catch (error) {
            throw new Error(`Failed to generate SBOM: ${error}`);
        }
    }
    async scanSBOM(sbom) {
        const reportId = `sbom-${Date.now()}`;
        const startTime = Date.now();
        try {
            const vulnerabilities = [];
            // Check each component for known vulnerabilities
            for (const component of sbom.components) {
                const componentVulns = await this.checkComponentVulnerabilities(component);
                vulnerabilities.push(...componentVulns);
            }
            const report = {
                id: reportId,
                timestamp: new Date(),
                scanType: 'dependency',
                status: 'completed',
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                metadata: {
                    scanner: 'sbom-scanner',
                    version: '1.0.0',
                    duration: Date.now() - startTime
                }
            };
            this.scanResults.set(reportId, report);
            return report;
        }
        catch (error) {
            throw new Error(`SBOM scan failed: ${error}`);
        }
    }
    async checkComponentVulnerabilities(component) {
        // Mock vulnerability checking - replace with actual vulnerability database queries
        const mockVulns = [];
        // Simulate finding vulnerabilities for certain packages
        if (component.name.includes('lodash') && component.version < '4.17.21') {
            mockVulns.push({
                id: `vuln-${component.name}-001`,
                title: 'Prototype Pollution in lodash',
                description: 'lodash versions prior to 4.17.21 are vulnerable to prototype pollution',
                severity: 'high',
                cvss: 7.5,
                package: component.name,
                version: component.version,
                fixedVersion: '4.17.21',
                references: ['https://github.com/advisories/GHSA-35jh-r3h4-6jhm'],
                remediation: 'Update lodash to version 4.17.21 or later'
            });
        }
        return mockVulns;
    }
    async getContinuousMonitoringStatus() {
        const activeScans = this.scanQueue.filter(job => job.status === 'running').length;
        const queuedScans = this.scanQueue.filter(job => job.status === 'queued').length;
        const recentScans = this.scanHistory.filter(scan => scan.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000));
        const totalVulnerabilities = recentScans.reduce((sum, scan) => sum + (scan.vulnerabilityCount || 0), 0);
        const criticalVulnerabilities = recentScans.reduce((sum, scan) => sum + (scan.criticalCount || 0), 0);
        return {
            isActive: activeScans > 0,
            activeScans,
            queuedScans,
            scansLast24h: recentScans.length,
            vulnerabilitiesFound: totalVulnerabilities,
            criticalVulnerabilitiesFound: criticalVulnerabilities,
            lastScanTime: recentScans.length > 0 ?
                Math.max(...recentScans.map(s => s.timestamp.getTime())) : null,
            nextScheduledScan: this.getNextScheduledScan()
        };
    }
    getNextScheduledScan() {
        // Mock implementation - would integrate with actual scheduler
        return new Date(Date.now() + 24 * 60 * 60 * 1000); // Next day
    }
    getScanHistory(limit = 50) {
        return this.scanHistory
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
}
exports.VulnerabilityScanner = VulnerabilityScanner;
exports.vulnerabilityScanner = new VulnerabilityScanner();
//# sourceMappingURL=vulnerabilityScanner.js.map