import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export interface VulnerabilityReport {
  id: string;
  timestamp: Date;
  scanType: 'dependency' | 'container' | 'code' | 'infrastructure';
  status: 'completed' | 'failed' | 'in_progress';
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  metadata: {
    scanner: string;
    version: string;
    duration: number;
  };
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  cvss: number;
  cve?: string;
  package?: string;
  version?: string;
  fixedVersion?: string;
  references: string[];
  remediation?: string;
}

export class VulnerabilityScanner {
  private scanResults: Map<string, VulnerabilityReport> = new Map();
  private scanQueue: ScanJob[] = [];
  private isScanning: boolean = false;
  private scanHistory: ScanHistory[] = [];

  async scanDependencies(projectPath: string): Promise<VulnerabilityReport> {
    const reportId = `dep-${Date.now()}`;
    const startTime = Date.now();

    try {
      // Use npm audit for Node.js dependencies
      const { stdout, stderr } = await execAsync('npm audit --json', {
        cwd: projectPath,
        timeout: 300000 // 5 minutes timeout
      });

      const auditResult = JSON.parse(stdout);
      const vulnerabilities = this.parseNpmAuditResult(auditResult);

      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'dependency',
        status: 'completed',
        vulnerabilities,
        summary: this.calculateSummary(vulnerabilities),
        metadata: {
          scanner: 'npm-audit',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      return report;
    } catch (error) {
      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'dependency',
        status: 'failed',
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        metadata: {
          scanner: 'npm-audit',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      throw new Error(`Dependency scan failed: ${error}`);
    }
  }

  async scanContainer(imageName: string): Promise<VulnerabilityReport> {
    const reportId = `container-${Date.now()}`;
    const startTime = Date.now();

    try {
      // Use Trivy for container scanning
      const { stdout } = await execAsync(`trivy image --format json ${imageName}`, {
        timeout: 600000 // 10 minutes timeout
      });

      const trivyResult = JSON.parse(stdout);
      const vulnerabilities = this.parseTrivyResult(trivyResult);

      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'container',
        status: 'completed',
        vulnerabilities,
        summary: this.calculateSummary(vulnerabilities),
        metadata: {
          scanner: 'trivy',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      return report;
    } catch (error) {
      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'container',
        status: 'failed',
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        metadata: {
          scanner: 'trivy',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      throw new Error(`Container scan failed: ${error}`);
    }
  }

  async scanCode(projectPath: string): Promise<VulnerabilityReport> {
    const reportId = `code-${Date.now()}`;
    const startTime = Date.now();

    try {
      // Use Semgrep for static code analysis
      const { stdout } = await execAsync(`semgrep --config=auto --json ${projectPath}`, {
        timeout: 600000 // 10 minutes timeout
      });

      const semgrepResult = JSON.parse(stdout);
      const vulnerabilities = this.parseSemgrepResult(semgrepResult);

      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'code',
        status: 'completed',
        vulnerabilities,
        summary: this.calculateSummary(vulnerabilities),
        metadata: {
          scanner: 'semgrep',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      return report;
    } catch (error) {
      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'code',
        status: 'failed',
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        metadata: {
          scanner: 'semgrep',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      throw new Error(`Code scan failed: ${error}`);
    }
  }

  async getReport(reportId: string): Promise<VulnerabilityReport | undefined> {
    return this.scanResults.get(reportId);
  }

  async getAllReports(): Promise<VulnerabilityReport[]> {
    return Array.from(this.scanResults.values());
  }

  async generateComplianceReport(): Promise<any> {
    const reports = await this.getAllReports();
    const criticalVulns = reports.flatMap(r => 
      r.vulnerabilities.filter(v => v.severity === 'critical')
    );

    return {
      timestamp: new Date(),
      totalScans: reports.length,
      criticalVulnerabilities: criticalVulns.length,
      complianceStatus: criticalVulns.length === 0 ? 'compliant' : 'non-compliant',
      recommendations: this.generateRecommendations(reports)
    };
  }

  private parseNpmAuditResult(auditResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (auditResult.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities)) {
        const vuln = vulnData as any;
        vulnerabilities.push({
          id: `npm-${packageName}-${vuln.via[0]?.source || 'unknown'}`,
          title: vuln.title || `Vulnerability in ${packageName}`,
          description: vuln.via[0]?.title || 'No description available',
          severity: this.mapSeverity(vuln.severity),
          cvss: vuln.via[0]?.cvss?.score || 0,
          cve: vuln.via[0]?.cve,
          package: packageName,
          version: vuln.via[0]?.range || 'unknown',
          fixedVersion: vuln.fixAvailable?.version,
          references: vuln.via[0]?.url ? [vuln.via[0].url] : [],
          remediation: vuln.fixAvailable ? `Update to version ${vuln.fixAvailable.version}` : 'No fix available'
        });
      }
    }

    return vulnerabilities;
  }

  private parseTrivyResult(trivyResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (trivyResult.Results) {
      for (const result of trivyResult.Results) {
        if (result.Vulnerabilities) {
          for (const vuln of result.Vulnerabilities) {
            vulnerabilities.push({
              id: vuln.VulnerabilityID,
              title: vuln.Title || vuln.VulnerabilityID,
              description: vuln.Description || 'No description available',
              severity: this.mapSeverity(vuln.Severity),
              cvss: vuln.CVSS?.nvd?.V3Score || 0,
              cve: vuln.VulnerabilityID,
              package: vuln.PkgName,
              version: vuln.InstalledVersion,
              fixedVersion: vuln.FixedVersion,
              references: vuln.References || [],
              remediation: vuln.FixedVersion ? `Update to version ${vuln.FixedVersion}` : 'No fix available'
            });
          }
        }
      }
    }

    return vulnerabilities;
  }

  private parseSemgrepResult(semgrepResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (semgrepResult.results) {
      for (const result of semgrepResult.results) {
        vulnerabilities.push({
          id: `semgrep-${result.check_id}`,
          title: result.extra?.message || result.check_id,
          description: result.extra?.message || 'Code security issue detected',
          severity: this.mapSemgrepSeverity(result.extra?.severity),
          cvss: this.severityToCvss(result.extra?.severity),
          references: result.extra?.references || [],
          remediation: result.extra?.fix || 'Review and fix the identified code issue'
        });
      }
    }

    return vulnerabilities;
  }

  private mapSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
    const severityMap: Record<string, 'critical' | 'high' | 'medium' | 'low'> = {
      'critical': 'critical',
      'high': 'high',
      'moderate': 'medium',
      'medium': 'medium',
      'low': 'low',
      'info': 'low'
    };

    return severityMap[severity.toLowerCase()] || 'medium';
  }

  private mapSemgrepSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
    const severityMap: Record<string, 'critical' | 'high' | 'medium' | 'low'> = {
      'error': 'high',
      'warning': 'medium',
      'info': 'low'
    };

    return severityMap[severity?.toLowerCase()] || 'medium';
  }

  private severityToCvss(severity: string): number {
    const cvssMap: Record<string, number> = {
      'critical': 9.0,
      'high': 7.0,
      'medium': 5.0,
      'low': 3.0
    };

    return cvssMap[severity?.toLowerCase()] || 5.0;
  }

  private calculateSummary(vulnerabilities: Vulnerability[]) {
    const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };
    
    for (const vuln of vulnerabilities) {
      summary.total++;
      summary[vuln.severity]++;
    }

    return summary;
  }

  private generateRecommendations(reports: VulnerabilityReport[]): string[] {
    const recommendations: string[] = [];
    
    const criticalCount = reports.reduce((sum, r) => sum + r.summary.critical, 0);
    const highCount = reports.reduce((sum, r) => sum + r.summary.high, 0);

    if (criticalCount > 0) {
      recommendations.push(`Address ${criticalCount} critical vulnerabilities immediately`);
    }

    if (highCount > 0) {
      recommendations.push(`Plan remediation for ${highCount} high-severity vulnerabilities`);
    }

    recommendations.push('Implement automated vulnerability scanning in CI/CD pipeline');
    recommendations.push('Establish regular security review processes');

    return recommendations;
  }

  // Enhanced scanning capabilities
  async scheduleScan(scanType: VulnerabilityReport['scanType'], target: string, schedule?: string): Promise<string> {
    const jobId = `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const job: ScanJob = {
      id: jobId,
      scanType,
      target,
      schedule,
      status: 'queued',
      createdAt: new Date()
    };

    this.scanQueue.push(job);
    this.processScanQueue();
    
    return jobId;
  }

  private async processScanQueue(): Promise<void> {
    if (this.isScanning || this.scanQueue.length === 0) return;
    
    this.isScanning = true;
    
    while (this.scanQueue.length > 0) {
      const job = this.scanQueue.shift()!;
      job.status = 'running';
      job.startedAt = new Date();
      
      try {
        let report: VulnerabilityReport;
        
        switch (job.scanType) {
          case 'dependency':
            report = await this.scanDependencies(job.target);
            break;
          case 'container':
            report = await this.scanContainer(job.target);
            break;
          case 'code':
            report = await this.scanCode(job.target);
            break;
          case 'infrastructure':
            report = await this.scanInfrastructure(job.target);
            break;
          default:
            throw new Error(`Unknown scan type: ${job.scanType}`);
        }
        
        job.status = 'completed';
        job.completedAt = new Date();
        job.reportId = report.id;
        
        this.scanHistory.push({
          jobId: job.id,
          scanType: job.scanType,
          target: job.target,
          status: 'completed',
          vulnerabilityCount: report.summary.total,
          criticalCount: report.summary.critical,
          timestamp: new Date()
        });
        
      } catch (error) {
        job.status = 'failed';
        job.error = error instanceof Error ? error.message : String(error);
        job.completedAt = new Date();
        
        this.scanHistory.push({
          jobId: job.id,
          scanType: job.scanType,
          target: job.target,
          status: 'failed',
          error: job.error,
          timestamp: new Date()
        });
      }
    }
    
    this.isScanning = false;
  }

  async scanInfrastructure(target: string): Promise<VulnerabilityReport> {
    const reportId = `infra-${Date.now()}`;
    const startTime = Date.now();

    try {
      // Simulate infrastructure scanning (replace with actual tools like Nessus, OpenVAS)
      const vulnerabilities = await this.performInfrastructureScan(target);

      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'infrastructure',
        status: 'completed',
        vulnerabilities,
        summary: this.calculateSummary(vulnerabilities),
        metadata: {
          scanner: 'infrastructure-scanner',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      return report;
    } catch (error) {
      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'infrastructure',
        status: 'failed',
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        metadata: {
          scanner: 'infrastructure-scanner',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      throw new Error(`Infrastructure scan failed: ${error}`);
    }
  }

  private async performInfrastructureScan(target: string): Promise<Vulnerability[]> {
    // Mock infrastructure vulnerabilities - replace with actual scanning logic
    const mockVulnerabilities: Vulnerability[] = [
      {
        id: 'infra-001',
        title: 'Outdated SSL/TLS Configuration',
        description: 'Server supports deprecated TLS versions',
        severity: 'medium',
        cvss: 5.3,
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228'],
        remediation: 'Update SSL/TLS configuration to support only TLS 1.2 and above'
      },
      {
        id: 'infra-002',
        title: 'Open Administrative Ports',
        description: 'Administrative ports are accessible from the internet',
        severity: 'high',
        cvss: 7.5,
        references: ['https://owasp.org/www-project-top-ten/'],
        remediation: 'Restrict access to administrative ports using firewall rules'
      }
    ];

    return mockVulnerabilities;
  }

  async generateSBOM(projectPath: string): Promise<SBOM> {
    // Software Bill of Materials generation
    const packageJsonPath = path.join(projectPath, 'package.json');
    
    try {
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
      
      const components: SBOMComponent[] = Object.entries(dependencies).map(([name, version]) => ({
        name,
        version: String(version).replace(/^[\^~]/, ''),
        type: 'library',
        supplier: 'npm',
        licenses: [], // Would need to fetch from package info
        hashes: [] // Would need to calculate from package files
      }));

      return {
        bomFormat: 'CycloneDX',
        specVersion: '1.4',
        version: 1,
        metadata: {
          timestamp: new Date(),
          tools: ['vulnerability-scanner'],
          component: {
            name: packageJson.name || 'unknown',
            version: packageJson.version || '1.0.0',
            type: 'application'
          }
        },
        components
      };
    } catch (error) {
      throw new Error(`Failed to generate SBOM: ${error}`);
    }
  }

  async scanSBOM(sbom: SBOM): Promise<VulnerabilityReport> {
    const reportId = `sbom-${Date.now()}`;
    const startTime = Date.now();

    try {
      const vulnerabilities: Vulnerability[] = [];
      
      // Check each component for known vulnerabilities
      for (const component of sbom.components) {
        const componentVulns = await this.checkComponentVulnerabilities(component);
        vulnerabilities.push(...componentVulns);
      }

      const report: VulnerabilityReport = {
        id: reportId,
        timestamp: new Date(),
        scanType: 'dependency',
        status: 'completed',
        vulnerabilities,
        summary: this.calculateSummary(vulnerabilities),
        metadata: {
          scanner: 'sbom-scanner',
          version: '1.0.0',
          duration: Date.now() - startTime
        }
      };

      this.scanResults.set(reportId, report);
      return report;
    } catch (error) {
      throw new Error(`SBOM scan failed: ${error}`);
    }
  }

  private async checkComponentVulnerabilities(component: SBOMComponent): Promise<Vulnerability[]> {
    // Mock vulnerability checking - replace with actual vulnerability database queries
    const mockVulns: Vulnerability[] = [];
    
    // Simulate finding vulnerabilities for certain packages
    if (component.name.includes('lodash') && component.version < '4.17.21') {
      mockVulns.push({
        id: `vuln-${component.name}-001`,
        title: 'Prototype Pollution in lodash',
        description: 'lodash versions prior to 4.17.21 are vulnerable to prototype pollution',
        severity: 'high',
        cvss: 7.5,
        package: component.name,
        version: component.version,
        fixedVersion: '4.17.21',
        references: ['https://github.com/advisories/GHSA-35jh-r3h4-6jhm'],
        remediation: 'Update lodash to version 4.17.21 or later'
      });
    }
    
    return mockVulns;
  }

  async getContinuousMonitoringStatus(): Promise<ContinuousMonitoringStatus> {
    const activeScans = this.scanQueue.filter(job => job.status === 'running').length;
    const queuedScans = this.scanQueue.filter(job => job.status === 'queued').length;
    const recentScans = this.scanHistory.filter(
      scan => scan.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000)
    );
    
    const totalVulnerabilities = recentScans.reduce((sum, scan) => sum + (scan.vulnerabilityCount || 0), 0);
    const criticalVulnerabilities = recentScans.reduce((sum, scan) => sum + (scan.criticalCount || 0), 0);
    
    return {
      isActive: activeScans > 0,
      activeScans,
      queuedScans,
      scansLast24h: recentScans.length,
      vulnerabilitiesFound: totalVulnerabilities,
      criticalVulnerabilitiesFound: criticalVulnerabilities,
      lastScanTime: recentScans.length > 0 ? 
        Math.max(...recentScans.map(s => s.timestamp.getTime())) : null,
      nextScheduledScan: this.getNextScheduledScan()
    };
  }

  private getNextScheduledScan(): Date | null {
    // Mock implementation - would integrate with actual scheduler
    return new Date(Date.now() + 24 * 60 * 60 * 1000); // Next day
  }

  getScanHistory(limit: number = 50): ScanHistory[] {
    return this.scanHistory
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }
}

// Additional interfaces for enhanced scanning
interface ScanJob {
  id: string;
  scanType: VulnerabilityReport['scanType'];
  target: string;
  schedule?: string;
  status: 'queued' | 'running' | 'completed' | 'failed';
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  reportId?: string;
  error?: string;
}

interface ScanHistory {
  jobId: string;
  scanType: VulnerabilityReport['scanType'];
  target: string;
  status: 'completed' | 'failed';
  vulnerabilityCount?: number;
  criticalCount?: number;
  error?: string;
  timestamp: Date;
}

interface SBOM {
  bomFormat: string;
  specVersion: string;
  version: number;
  metadata: {
    timestamp: Date;
    tools: string[];
    component: {
      name: string;
      version: string;
      type: string;
    };
  };
  components: SBOMComponent[];
}

interface SBOMComponent {
  name: string;
  version: string;
  type: string;
  supplier: string;
  licenses: string[];
  hashes: string[];
}

interface ContinuousMonitoringStatus {
  isActive: boolean;
  activeScans: number;
  queuedScans: number;
  scansLast24h: number;
  vulnerabilitiesFound: number;
  criticalVulnerabilitiesFound: number;
  lastScanTime: number | null;
  nextScheduledScan: Date | null;
}

export const vulnerabilityScanner = new VulnerabilityScanner();